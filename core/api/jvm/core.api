public abstract interface class sk/ai/net/DataDescriptor {
	public abstract fun getBits ()I
	public abstract fun getMaxValue ()D
	public abstract fun getMinValue ()D
	public abstract fun getName ()Ljava/lang/String;
	public abstract fun isFloatingPoint ()Z
	public abstract fun isSigned ()Z
}

public final class sk/ai/net/Shape {
	public fun <init> ([I)V
	public fun equals (Ljava/lang/Object;)Z
	public final fun getDimensions ()[I
	public final fun getRank ()I
	public final fun getVolume ()I
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public abstract interface class sk/ai/net/Tensor {
	public abstract fun acos ()Lsk/ai/net/Tensor;
	public abstract fun asin ()Lsk/ai/net/Tensor;
	public abstract fun atan ()Lsk/ai/net/Tensor;
	public abstract fun cbrt ()Lsk/ai/net/Tensor;
	public abstract fun cos ()Lsk/ai/net/Tensor;
	public abstract fun cosh ()Lsk/ai/net/Tensor;
	public abstract fun exp ()Lsk/ai/net/Tensor;
	public abstract fun getDataDescriptor ()Lsk/ai/net/DataDescriptor;
	public abstract fun getRank ()I
	public abstract fun getShape ()Lsk/ai/net/Shape;
	public abstract fun getSize ()I
	public abstract fun ln ()Lsk/ai/net/Tensor;
	public abstract fun log ()Lsk/ai/net/Tensor;
	public abstract fun matmul (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public abstract fun minus (D)Lsk/ai/net/Tensor;
	public abstract fun minus (I)Lsk/ai/net/Tensor;
	public abstract fun minus (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public abstract fun plus (D)Lsk/ai/net/Tensor;
	public abstract fun plus (I)Lsk/ai/net/Tensor;
	public abstract fun plus (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public abstract fun pow (D)Lsk/ai/net/Tensor;
	public abstract fun pow (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public abstract fun relu ()Lsk/ai/net/Tensor;
	public abstract fun sigmoid ()Lsk/ai/net/Tensor;
	public abstract fun sin ()Lsk/ai/net/Tensor;
	public abstract fun sinh ()Lsk/ai/net/Tensor;
	public abstract fun softmax ()Lsk/ai/net/Tensor;
	public abstract fun softmax (I)Lsk/ai/net/Tensor;
	public abstract fun sqrt ()Lsk/ai/net/Tensor;
	public abstract fun t ()Lsk/ai/net/Tensor;
	public abstract fun tan ()Lsk/ai/net/Tensor;
	public abstract fun tanh ()Lsk/ai/net/Tensor;
}

public final class sk/ai/net/Tensor$DefaultImpls {
	public static fun getRank (Lsk/ai/net/Tensor;)I
	public static fun getSize (Lsk/ai/net/Tensor;)I
}

public abstract interface class sk/ai/net/TensorFactory {
	public abstract fun createTensor (Lsk/ai/net/Shape;Lsk/ai/net/DataDescriptor;[D)Lsk/ai/net/Tensor;
}

public abstract interface class sk/ai/net/dsl/DENSE : sk/ai/net/dsl/NetworkDslItem {
	public abstract fun bias (Lkotlin/jvm/functions/Function1;)V
	public abstract fun getActivation ()Lkotlin/jvm/functions/Function1;
	public abstract fun setActivation (Lkotlin/jvm/functions/Function1;)V
	public abstract fun weights (Lkotlin/jvm/functions/Function1;)V
}

public final class sk/ai/net/dsl/DenseImpl : sk/ai/net/dsl/DENSE {
	public fun <init> (IILjava/lang/String;)V
	public fun bias (Lkotlin/jvm/functions/Function1;)V
	public final fun create ()Ljava/util/List;
	public fun getActivation ()Lkotlin/jvm/functions/Function1;
	public fun setActivation (Lkotlin/jvm/functions/Function1;)V
	public fun weights (Lkotlin/jvm/functions/Function1;)V
}

public final class sk/ai/net/dsl/NetworkBuilder {
	public fun <init> ()V
	public final fun add ([Lsk/ai/net/nn/Module;)Lsk/ai/net/dsl/NetworkBuilder;
	public final fun build ()Lsk/ai/net/nn/Module;
}

public final class sk/ai/net/dsl/NetworkBuilderKt {
	public static final fun createLinear (IILjava/lang/String;Lsk/ai/net/Tensor;Lsk/ai/net/Tensor;)Lsk/ai/net/nn/Linear;
	public static synthetic fun createLinear$default (IILjava/lang/String;Lsk/ai/net/Tensor;Lsk/ai/net/Tensor;ILjava/lang/Object;)Lsk/ai/net/nn/Linear;
	public static final fun network (Lkotlin/jvm/functions/Function1;)Lsk/ai/net/nn/Module;
}

public abstract interface annotation class sk/ai/net/dsl/NetworkDsl : java/lang/annotation/Annotation {
}

public abstract interface class sk/ai/net/dsl/NetworkDslItem {
}

public abstract interface class sk/ai/net/dsl/NeuralNetworkDsl : sk/ai/net/dsl/NetworkDslItem {
	public abstract fun dense (ILjava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public abstract fun input (ILjava/lang/String;)V
}

public final class sk/ai/net/dsl/NeuralNetworkDsl$DefaultImpls {
	public static synthetic fun dense$default (Lsk/ai/net/dsl/NeuralNetworkDsl;ILjava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public static synthetic fun input$default (Lsk/ai/net/dsl/NeuralNetworkDsl;ILjava/lang/String;ILjava/lang/Object;)V
}

public final class sk/ai/net/impl/BuiltInDoubleDataDescriptor : sk/ai/net/DataDescriptor {
	public fun <init> ()V
	public fun getBits ()I
	public fun getMaxValue ()D
	public fun getMinValue ()D
	public fun getName ()Ljava/lang/String;
	public fun isFloatingPoint ()Z
	public fun isSigned ()Z
}

public final class sk/ai/net/impl/DefaultTensorFactory : sk/ai/net/TensorFactory {
	public fun <init> ()V
	public fun createTensor (Lsk/ai/net/Shape;Lsk/ai/net/DataDescriptor;[D)Lsk/ai/net/Tensor;
}

public final class sk/ai/net/impl/DoublesTensor : sk/ai/net/impl/TypedTensor {
	public static final field Companion Lsk/ai/net/impl/DoublesTensor$Companion;
	public fun <init> (Lsk/ai/net/Shape;D)V
	public synthetic fun <init> (Lsk/ai/net/Shape;DILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun <init> (Lsk/ai/net/Shape;[D)V
	public fun acos ()Lsk/ai/net/Tensor;
	public fun asin ()Lsk/ai/net/Tensor;
	public fun atan ()Lsk/ai/net/Tensor;
	public fun cbrt ()Lsk/ai/net/Tensor;
	public final fun component1 ()Lsk/ai/net/Shape;
	public final fun component2 ()[D
	public final fun computeStrides ([I)[I
	public final fun copy (Lsk/ai/net/Shape;[D)Lsk/ai/net/impl/DoublesTensor;
	public static synthetic fun copy$default (Lsk/ai/net/impl/DoublesTensor;Lsk/ai/net/Shape;[DILjava/lang/Object;)Lsk/ai/net/impl/DoublesTensor;
	public fun cos ()Lsk/ai/net/Tensor;
	public fun cosh ()Lsk/ai/net/Tensor;
	public final fun div (D)Lsk/ai/net/impl/TypedTensor;
	public final fun div (Lsk/ai/net/impl/TypedTensor;)Lsk/ai/net/impl/TypedTensor;
	public fun equals (Ljava/lang/Object;)Z
	public fun exp ()Lsk/ai/net/Tensor;
	public fun get ([I)Ljava/lang/Double;
	public synthetic fun get ([I)Ljava/lang/Object;
	public fun get ([Lkotlin/ranges/IntRange;)Lsk/ai/net/impl/TypedTensor;
	public fun getDataDescriptor ()Lsk/ai/net/DataDescriptor;
	public final fun getElements ()[D
	public fun getRank ()I
	public fun getShape ()Lsk/ai/net/Shape;
	public fun getSize ()I
	public fun hashCode ()I
	public fun ln ()Lsk/ai/net/Tensor;
	public fun log ()Lsk/ai/net/Tensor;
	public fun matmul (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public synthetic fun minus (D)Lsk/ai/net/Tensor;
	public fun minus (D)Lsk/ai/net/impl/TypedTensor;
	public fun minus (I)Lsk/ai/net/Tensor;
	public fun minus (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public fun plus (D)Lsk/ai/net/Tensor;
	public fun plus (I)Lsk/ai/net/Tensor;
	public fun plus (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public fun pow (D)Lsk/ai/net/Tensor;
	public fun pow (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public fun relu ()Lsk/ai/net/Tensor;
	public fun sigmoid ()Lsk/ai/net/Tensor;
	public fun sin ()Lsk/ai/net/Tensor;
	public fun sinh ()Lsk/ai/net/Tensor;
	public fun softmax ()Lsk/ai/net/Tensor;
	public fun softmax (I)Lsk/ai/net/Tensor;
	public fun sqrt ()Lsk/ai/net/Tensor;
	public fun t ()Lsk/ai/net/Tensor;
	public fun tan ()Lsk/ai/net/Tensor;
	public fun tanh ()Lsk/ai/net/Tensor;
	public final fun times (D)Lsk/ai/net/impl/TypedTensor;
	public final fun times (Lsk/ai/net/impl/TypedTensor;)Lsk/ai/net/impl/TypedTensor;
	public fun toString ()Ljava/lang/String;
	public final fun unravelIndex (I[I[I)[I
}

public final class sk/ai/net/impl/DoublesTensor$Companion {
	public final fun getDoubleDataDescriptor ()Lsk/ai/net/impl/BuiltInDoubleDataDescriptor;
}

public final class sk/ai/net/impl/DoublesTensorKt {
	public static final fun prod (Lsk/ai/net/impl/DoublesTensor;)D
}

public final class sk/ai/net/impl/TensorFactoriesKt {
	public static final fun createTensor (Lsk/ai/net/Shape;[D)Lsk/ai/net/Tensor;
	public static final fun createTensor ([D)Lsk/ai/net/Tensor;
}

public abstract interface class sk/ai/net/impl/TypedTensor : sk/ai/net/Tensor {
	public abstract fun get ([I)Ljava/lang/Object;
	public abstract fun get ([Lkotlin/ranges/IntRange;)Lsk/ai/net/impl/TypedTensor;
}

public final class sk/ai/net/impl/TypedTensor$DefaultImpls {
	public static fun getRank (Lsk/ai/net/impl/TypedTensor;)I
	public static fun getSize (Lsk/ai/net/impl/TypedTensor;)I
}

public final class sk/ai/net/nn/Input : sk/ai/net/nn/Module {
	public fun <init> (Lsk/ai/net/Shape;Ljava/lang/String;)V
	public synthetic fun <init> (Lsk/ai/net/Shape;Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
}

public final class sk/ai/net/nn/Linear : sk/ai/net/nn/Module, sk/ai/net/nn/reflection/ModuleParameters {
	public fun <init> (IILjava/lang/String;Lsk/ai/net/Tensor;Lsk/ai/net/Tensor;Ljava/util/List;)V
	public synthetic fun <init> (IILjava/lang/String;Lsk/ai/net/Tensor;Lsk/ai/net/Tensor;Ljava/util/List;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public fun getParams ()Ljava/util/List;
}

public abstract class sk/ai/net/nn/Module {
	public fun <init> ()V
	public abstract fun forward (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public abstract fun getModules ()Ljava/util/List;
	public abstract fun getName ()Ljava/lang/String;
	public final fun invoke (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
}

public final class sk/ai/net/nn/activations/ActivationsWrapperModule : sk/ai/net/nn/Module {
	public fun <init> (Lkotlin/jvm/functions/Function1;Ljava/lang/String;)V
	public fun forward (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
}

public final class sk/ai/net/nn/activations/ReLU : sk/ai/net/nn/Module {
	public fun <init> ()V
	public fun <init> (Ljava/lang/String;)V
	public synthetic fun <init> (Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
}

public final class sk/ai/net/nn/activations/Softmax : sk/ai/net/nn/Module {
	public fun <init> (ILjava/lang/String;)V
	public synthetic fun <init> (ILjava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
}

public final class sk/ai/net/nn/reflection/ModelSummaryKt {
	public static final fun summary (Lsk/ai/net/nn/Module;Lsk/ai/net/Shape;I)Ljava/lang/String;
	public static synthetic fun summary$default (Lsk/ai/net/nn/Module;Lsk/ai/net/Shape;IILjava/lang/Object;)Ljava/lang/String;
}

public abstract class sk/ai/net/nn/reflection/ModuleParameter {
	public abstract fun getName ()Ljava/lang/String;
	public abstract fun getValue ()Lsk/ai/net/Tensor;
	public abstract fun setValue (Lsk/ai/net/Tensor;)V
}

public final class sk/ai/net/nn/reflection/ModuleParameter$BiasParameter : sk/ai/net/nn/reflection/ModuleParameter {
	public fun <init> (Ljava/lang/String;Lsk/ai/net/Tensor;)V
	public final fun component1 ()Ljava/lang/String;
	public final fun component2 ()Lsk/ai/net/Tensor;
	public final fun copy (Ljava/lang/String;Lsk/ai/net/Tensor;)Lsk/ai/net/nn/reflection/ModuleParameter$BiasParameter;
	public static synthetic fun copy$default (Lsk/ai/net/nn/reflection/ModuleParameter$BiasParameter;Ljava/lang/String;Lsk/ai/net/Tensor;ILjava/lang/Object;)Lsk/ai/net/nn/reflection/ModuleParameter$BiasParameter;
	public fun equals (Ljava/lang/Object;)Z
	public fun getName ()Ljava/lang/String;
	public fun getValue ()Lsk/ai/net/Tensor;
	public fun hashCode ()I
	public fun setValue (Lsk/ai/net/Tensor;)V
	public fun toString ()Ljava/lang/String;
}

public final class sk/ai/net/nn/reflection/ModuleParameter$WeightParameter : sk/ai/net/nn/reflection/ModuleParameter {
	public fun <init> (Ljava/lang/String;Lsk/ai/net/Tensor;)V
	public final fun component1 ()Ljava/lang/String;
	public final fun component2 ()Lsk/ai/net/Tensor;
	public final fun copy (Ljava/lang/String;Lsk/ai/net/Tensor;)Lsk/ai/net/nn/reflection/ModuleParameter$WeightParameter;
	public static synthetic fun copy$default (Lsk/ai/net/nn/reflection/ModuleParameter$WeightParameter;Ljava/lang/String;Lsk/ai/net/Tensor;ILjava/lang/Object;)Lsk/ai/net/nn/reflection/ModuleParameter$WeightParameter;
	public fun equals (Ljava/lang/Object;)Z
	public fun getName ()Ljava/lang/String;
	public fun getValue ()Lsk/ai/net/Tensor;
	public fun hashCode ()I
	public fun setValue (Lsk/ai/net/Tensor;)V
	public fun toString ()Ljava/lang/String;
}

public abstract interface class sk/ai/net/nn/reflection/ModuleParameters {
	public abstract fun getParams ()Ljava/util/List;
}

public final class sk/ai/net/nn/reflection/ModuleParametersKt {
	public static final fun bias (Ljava/util/List;)Lsk/ai/net/nn/reflection/ModuleParameter$BiasParameter;
	public static final fun by (Ljava/util/List;Ljava/lang/String;)Lsk/ai/net/nn/reflection/ModuleParameter;
	public static final fun weights (Ljava/util/List;)Lsk/ai/net/nn/reflection/ModuleParameter$WeightParameter;
}

public final class sk/ai/net/nn/reflection/ModuleToolsKt {
	public static final fun toCustomString (Lsk/ai/net/nn/Module;Ljava/lang/String;)Ljava/lang/String;
	public static synthetic fun toCustomString$default (Lsk/ai/net/nn/Module;Ljava/lang/String;ILjava/lang/Object;)Ljava/lang/String;
	public static final fun toVisualString (Lsk/ai/net/nn/Module;)Ljava/lang/String;
}

public final class sk/ai/net/nn/reflection/NodeSummary {
	public fun <init> (Ljava/lang/String;Lsk/ai/net/Shape;Lsk/ai/net/Shape;J)V
	public final fun component1 ()Ljava/lang/String;
	public final fun component2 ()Lsk/ai/net/Shape;
	public final fun component3 ()Lsk/ai/net/Shape;
	public final fun component4 ()J
	public final fun copy (Ljava/lang/String;Lsk/ai/net/Shape;Lsk/ai/net/Shape;J)Lsk/ai/net/nn/reflection/NodeSummary;
	public static synthetic fun copy$default (Lsk/ai/net/nn/reflection/NodeSummary;Ljava/lang/String;Lsk/ai/net/Shape;Lsk/ai/net/Shape;JILjava/lang/Object;)Lsk/ai/net/nn/reflection/NodeSummary;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getInput ()Lsk/ai/net/Shape;
	public final fun getName ()Ljava/lang/String;
	public final fun getOutput ()Lsk/ai/net/Shape;
	public final fun getParams ()J
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ai/net/nn/reflection/ParamToolsKt {
	public static final fun flattenParams (Lsk/ai/net/nn/Module;)Ljava/util/List;
}

public final class sk/ai/net/nn/reflection/Summary {
	public fun <init> ()V
	public final fun getNodes ()Ljava/util/List;
	public final fun printSummary (Ljava/util/List;)Ljava/lang/String;
	public final fun summary (Lsk/ai/net/nn/Module;Lsk/ai/net/Shape;I)Ljava/util/List;
	public static synthetic fun summary$default (Lsk/ai/net/nn/reflection/Summary;Lsk/ai/net/nn/Module;Lsk/ai/net/Shape;IILjava/lang/Object;)Ljava/util/List;
}

public final class sk/ai/net/nn/reflection/table/Cell {
	public fun <init> (Ljava/lang/String;)V
	public final fun getContent ()Ljava/lang/String;
}

public final class sk/ai/net/nn/reflection/table/CellStyle {
	public fun <init> ()V
	public final fun getBorder ()Z
	public final fun setBorder (Z)V
}

public final class sk/ai/net/nn/reflection/table/Header {
	public fun <init> ()V
	public final fun getRows ()Ljava/util/List;
	public final fun row (Lkotlin/jvm/functions/Function1;)V
}

public final class sk/ai/net/nn/reflection/table/Row {
	public fun <init> ()V
	public final fun cell (Ljava/lang/Object;)V
	public final fun getCells ()Ljava/util/List;
}

public final class sk/ai/net/nn/reflection/table/Table {
	public fun <init> ()V
	public final fun cellStyle (Lkotlin/jvm/functions/Function1;)V
	public final fun getCellStyle ()Lsk/ai/net/nn/reflection/table/CellStyle;
	public final fun getHeader ()Lsk/ai/net/nn/reflection/table/Header;
	public final fun getRows ()Ljava/util/List;
	public final fun header (Lkotlin/jvm/functions/Function1;)V
	public final fun row (Lkotlin/jvm/functions/Function1;)V
	public final fun setHeader (Lsk/ai/net/nn/reflection/table/Header;)V
	public fun toString ()Ljava/lang/String;
}

public final class sk/ai/net/nn/reflection/table/TableBuilderKt {
	public static final fun table (Lkotlin/jvm/functions/Function1;)Lsk/ai/net/nn/reflection/table/Table;
}

public final class sk/ai/net/nn/topology/MLP : sk/ai/net/nn/Module, sk/ai/net/nn/reflection/ModuleParameters {
	public fun <init> ([Lsk/ai/net/nn/Module;Ljava/lang/String;)V
	public synthetic fun <init> ([Lsk/ai/net/nn/Module;Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ai/net/Tensor;)Lsk/ai/net/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public fun getParams ()Ljava/util/List;
}

public final class sk/ai/net/performance/MeasureKt {
	public static final fun measureBlock (Lkotlin/jvm/functions/Function0;)J
}

public final class sk/ai/net/performance/Measure_jvmKt {
	public static final fun currentMillis ()J
}

